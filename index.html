<!DOCTYPE html>
<html>

	<head>
	<style>
	
		body {
			background-image: url('Background.png');
		}
		
	.sprite {
		position: absolute;
		background-size: cover;
		background-position: center;
	}
		
	.tooltip {
        visibility: hidden;
        width: 120px;
        background-color: black;
        color: #fff;
        text-align: center;
        border-radius: 6px;
        padding: 5px;
        position: absolute;
        z-index: 1;
        bottom: 100%;
        left: 50%;
        margin-left: -60px;
        /* center the tooltip */
        opacity: 0;
        transition: opacity 1s;
    }

    .sprite:hover .tooltip {
        visibility: visible;
        opacity: 1;
    }
	
	
	.contextMenu {
		position: absolute;
		bottom:0;
		right:30px;
		width:30%;
		height:30%;
		margin: 20px;
		background-color: #7C7C7C;
		color: black;
		opacity: 0.5;
		z-index: 1;
		transition: opacity 1s, background-color 1s, color 1s;
		
	}
	.contextMenu:hover {
		background-color: #3D3D3D;
		color: white;
		opacity: 1;
	}
	.contextMenu, p {
		padding: 15px;
	}
	
	.overlayDisplay {
		position:absolute;
		bottom: 0px;
		right: 0px;
		width: 100%;
		height: 100%;
		background-color: #7C7C7C;
		opacity: 70%;
		z-index: -1;
		
	}
	.InvDisplay {
		position : absolute;
		left : 50px;
		bottom : 50px;
	}
		
		
	</style>
	</head>
	
	<body>
	
	<script>
	
	//CONVERSATION TREES
		let PreLoad = {
			name: "Thank you!",
			start: {
				text: "For a better experience, please press F11 to go fullscreen. <br> Press Escape to open the Dev Menu, then Press 'Spawn Player.' Then, press 'Room ONE', I really hope you enjoy!",
				options: []
			}
		}
		
		let FreshKill = {
			name: "I...I killed it.",
				start: {
					text: "Whatever that...thing...was. I killed it.",
					options: []
				}
		}
	
		let InnerSanctum = {
			name: "The Sacred Temple, Inner Sanctum",
			start: {
				
				text: "<i>The hidden away core of the Sacred Temple. Very few are blessed (or cursed) enough to have the honor of seeing it.</i><br>The Information above is somehow known to you..although you arent sure how.",
					options : [{text: "Notepad in your pocket", next: "list"}, {text: "Card displaying Gold", next: "goldCard"}]
			},
			list: {
				text: "Pulling the notepad out of your front shirt pocket, flipping through the pages, you find nothing of value. <br> <i>Through broken pencil markings, maybe the work 'Lumen' is barely legible? It's still hard to tell</i>",
				options : [{text: "back", next: "start"}]
			},
			goldCard: {
				text: "In your front pants pocket is a slim, metal card with a display on the front. Multiple lines are visible, although only one is currently occupied.",
				options: []
			}
		
		}
		
		let InnerHall = {
			name: "The Sacred Temple, Inner Hall",
			start: {
				
				text: "Hall leading to the Inner Sanctum",
					options : []
			}
		
		}
		
		let TribalLeader = {
			name: "Tribal Leader",
			start: {
				text: "Oh by the way, my name is ironic. Kind of like the subway memes. My Brother in Christ, YOU made the sandwich",
				options: [{text: "Who are you?", next: "WendigoGreet"}],
				
			},
			WendigoGreet: {
				text: "You can call me Wendigo. I can serve as the Judge, Jury, and Executioner of your experience here.",
				options: [{text: "Will You Spawn a Clone of yourself that I can fight?", next: "SpawnClone"}, {text: "I wish to dress as you", next: "Disguise"}, { text:" I wish to convert my gold to attack power", next: "Convert"},{text: "Back", next: "start"}]
			},
			SpawnClone: {
				text: "Ah! A hasty one arent you? Alright, give it your best shot.",
				options: [{text: "Back", next: "start"}],
			},
			Disguise: {
				text: "Welcome to our commune, brother",
				options: [{text: "Back", next: "start"}]
			},
			Convert: {
				text: "As you wish...",
				options: [{text: "Back", next: "start"}]
			}
			
		}
		
		let ImpressedTribalLeader = {
			name: "Tribal Leader, slightly impressed",
			start: {
				text: "Huh...so you did it. You killed the clone of myself.",
				options: [ {text: "Your clone dropped this chain...", next: "chain"}, {text: "His body...He lost his color", next: "color"} ]
				},
			chain: {
				text: "Oh my....oh now that is interesting. Would you allow me to...see it for a moment?",
				options: [ {text: "Allow", next: "allowChain"}, {text: "Refuse", next: "refuseChain"} ]
			},
			allowChain: {
				text: "You gave me the chain",
				options: []
			},
			refuseChain: {
				text: "You didnt give me the chain.",
				options: []
			},
			color: {
				text: "Ah...So is the way of death in these parts. You go to the land of death and lose your color",
				options: []
			}
		};
		
		let HouseExterior = {
			name: "Stumbled on a house in the woods",
			start: {
				text: "Moving through the bramble, a faint house is barely visible",
				options: []
			}
		}
		
		let deathConversation = {
			name: "You have died",
			start: {
				text: "Between the shores of life and death, but destined to be cast into the sea.<br> <i>Abandon all hope, those who enter</i>",
				options: []
			}
		}
	
	
		
		let conversationNode = "start";
		let conversationTree = PreLoad;
		
	//GLOBAL HELPERS
	
			const FRAMERATE  = 16; //AMOUNT OF MILLISECONDS BETWEEN CYCLES 16 = 60fps
			
			function isFullscreen(){
				return(window.innerHeight == screen.height);
			};
			
			function getRandomfromInt(max){
				return Math.floor(Math.random() * max);
			}
			
			
	//CONTROLS

		let WASDcontrols = {moveUp : "w",
						moveDown: "s",
						moveLeft: "a",
						moveRight: "d"};
						
		let ArrowControls = {moveUp : "arrowup",
						moveDown: "arrowdown",
						moveLeft: "arrowleft",
						moveRight: "arrowright"};
						
		let activeControls = WASDcontrols;
	//ENTITY CLASS		
	
			let mapLimits = {xMax: screen.width, xMin: 0, yMax: screen.height, yMin: 0};
			
			let EntityList = [];
			
			class Entity {
				constructor(urlFolder, x, y, size, type, name){
				this.urlFolder = urlFolder;
				this.url = this.urlFolder + "/Front.gif";
				
					
				this.size = size; //Resolution of the sprite, width = size; height = size;
				this.x = x;
				this.y = y;
				this.type = type;	
				this.name = name;	//this will be the elements ID in the html
				this.velocity = {x: 0, y: 0};
				this.targetedPos = { x : 0, y : 0};
				this.moveSpeed = 0.5;
				this.distanceToTarget = {x: Math.abs(this.x - this.targetedPos.x), y: Math.abs(this.y - this.targetedPos.y)};
				
				this.facedDirection = "Back";
					
				this.onclickEnabled = false;
				
				this.wireFrameEnabled = true;
					
				this.attackPower = getRandomfromInt(10);
				this.healthPoints = getRandomfromInt(1000);
				
				this.conversationTree = PreLoad;
				
				this.inventory = []; //Inventory Array
				
					//THIS MIGHT BE TEMPORARY
						this.inventory.push( {name: "Gold", quantity: getRandomfromInt(100)});
				
				//THE ENTITY AUTOMATICALLY SPAWNS WHEN IT IS CALLED
				this.spawn();
				}
				
				spawn(){
				
				//creating the sprite
					const newSprite = document.createElement("div");
					newSprite.className = "sprite";
					this.SpriteInterval = setInterval( () => {
						newSprite.style.width = this.size + "px";
						newSprite.style.height = this.size + "px";
						newSprite.style.backgroundImage = 'url("' + this.url + '")';
					}, FRAMERATE);
					
					newSprite.style.top = this.y + "px";
					newSprite.style.left = this.x + "px";
					
					//Creating a tooltip attached to the Sprite with an onhover event
					
					 const tooltip = document.createElement("div");
					tooltip.className = "tooltip";
					newSprite.appendChild(tooltip);
					
					
					document.body.appendChild(newSprite);
					newSprite.setAttribute("id", this.name);

					
					console.log("Spawned " + this.name)
					
					newSprite.addEventListener("mousedown", () =>  {
								
									this.toggleOnclick();
											document.addEventListener('mousemove', (event) => {
											const mouseX = event.clientX;
											const mouseY = event.clientY;
											// You can use mouseX and mouseY wherever needed in your code
												if(this.onclickEnabled){
												this.targetedPos = { x: mouseX - this.size / 2, y: mouseY - this.size / 2 };
												};
											});
									});
					
					this.toolTipInterval = setInterval( () => {
								tooltip.innerHTML = " ' " + this.name 
											+ "' <br> HP : " + this.healthPoints 
											+ " <br> X: " + Math.floor(this.x) + " <br> Y: " + Math.floor(this.y) 
											+ "<br> Distance: " + Math.floor(this.distanceToTarget.x) + " " 
											+ Math.floor(this.distanceToTarget.y) + "<br> TYPE: " + this.type +  " <br> ATTACK: " + this.attackPower ;
					}, FRAMERATE);
					
					this.moveInterval = setInterval(() => { 
								this.lastPos = {x: this.x, y: this.y};
								this.x += this.velocity.x; this.y += this.velocity.y; 
								
								if(this.x > mapLimits.xMax || this.x < mapLimits.xMin){
									this.x = this.lastPos.x;
								};
								
								if(this.y > mapLimits.yMax || this.y < mapLimits.yMin){
									this.y = this.lastPos.y;
								};
								
									for(let i = 0; i < EntityList.length; i++){
										if(EntityList[i].name === this.name){
											//The entity we are comparing is the same, so dont do anything
											
										}else if( this.checkCollision( EntityList[i]) ){
												this.x = this.lastPos.x;
												this.y = this.lastPos.y;
												
												EntityList[i].x = EntityList[i].lastPos.x;
												EntityList[i].y = EntityList[i].lastPos.y;
												
												this.targetedPos.x = this.x;
												this.targetedPos.y = this.y;
												
												if(this.type === "Player"){
													if(EntityList[i].type === "Monster"){
														console.log("Interacting with Monster");
														//"Fuck it lets make em fight" -Satoshi Tajiri
														this.healthPoints -= EntityList[i].attackPower;
														EntityList[i].healthPoints -= this.attackPower;
														
														
														
														if(this.healthPoints <= 0){
																console.log("Player had died");
														};
														
														if(EntityList[i].healthPoints <= 0){
															
															//Looting
															for(let j = 0; j < EntityList[i].inventory.length; j++){
																
																	
																	EntityList[0].inventory.push(EntityList[i].inventory[j]);
																
																	
															}
															
															//Update Inventory
															InventoryDisplay.innerHTML = "Inventory : <br>";
															for(let j = 0; j < EntityList[0].inventory.length; j++){
																InventoryDisplay.innerHTML += " " + EntityList[0].inventory[j].name + " ( " + EntityList[0].inventory[j].quantity + " ) <br>";
															}
															
															
															
															EntityList[i].type = "Corpse";
																conversationTree = FreshKill;
																conversationNode = "start";
																UpdateConversationDisplay();
																
															
														}
														
														
													};
													
													if(EntityList[i].type === "NPC"){
														console.log("Interacting with NPC");
														 //"only when a mosquito lands om your testicle, will you realise theres a way to solve a problem without using violence" -Confusius
														 if(conversationTree != EntityList[i].conversationTree){
														 conversationTree = EntityList[i].conversationTree;
														 UpdateConversationDisplay();
														 }
														
														
														
													};
												};
												
											};
									};
										
								this.distanceToTarget = {x: Math.abs(this.x - this.targetedPos.x), y: Math.abs(this.y - this.targetedPos.y)};
								this.updatePos() }, FRAMERATE); //So this says "Move it by velocity everytime"
					
					this.directionInterval = setInterval(() => {
						// Change velocity toward the target
						if (this.x < this.targetedPos.x) {
							this.velocity.x = this.moveSpeed;
						} else if (this.x > this.targetedPos.x) {
							this.velocity.x = this.moveSpeed * -1;
						}else {
							
							this.velocity.x = 0;
						}

						if (this.y < this.targetedPos.y) {
							this.velocity.y =  this.moveSpeed;
						} else if (this.y > this.targetedPos.y) {
							this.velocity.y =  this.moveSpeed * -1;
						} else {
							this.velocity.y = 0;
						}

						// Change faced direction
						if (Math.abs(this.distanceToTarget.x) > Math.abs(this.distanceToTarget.y)) {
							if (this.targetedPos.x > this.x) {
								this.facedDirection = "Right";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							} else if (this.targetedPos.x < this.x) {
								this.facedDirection = "Left";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							}
						} else if (Math.abs(this.distanceToTarget.y) > Math.abs(this.distanceToTarget.x)) {
							if (this.targetedPos.y > this.y) {
								this.facedDirection = "Front";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							} else if (this.targetedPos.y < this.y) {
								this.facedDirection = "Back";
								this.url = this.urlFolder + "/" + this.facedDirection + ".gif";
							}
						} else if(this.healthPoints > 1) { 
							this.url = this.urlFolder + "/idle/" + this.facedDirection + ".gif";
						}else if(this.healthPoints <= 0){
							this.url = this.urlFolder + "/death/" + this.facedDirection + ".gif";
							
						}
					}, FRAMERATE);
					
							
				}
				
				
				
				remove(){
					const elementToRemove = document.getElementById(this.name);
					if (elementToRemove) {
						elementToRemove.parentNode.removeChild(elementToRemove);
							clearInterval(this.toolTipInterval);
							clearInterval(this.SpriteInterval);
							clearInterval(this.moveInterval);
							clearInterval(this.directionInterval);
							clearInterval(this.keyBoardInterval);
							clearInterval(this.deathInterval);
						}
						 // Remove the entity from the EntityList
							const index = EntityList.findIndex(entity => entity.name === this.name);
							if (index !== -1) {
								EntityList.splice(index, 1);
							}
				}
				
				updatePos(){
					const targeted = document.getElementById(this.name);
						
					targeted.style.top = this.y + "px";
					targeted.style.left = this.x + "px";
					
				}
				
				toggleOnclick(){				//Click Sprite once,it follows the mouse. Click again, stops following
					if (this.onclickEnabled) {
						this.onclickEnabled = false; 
					} else {
						this.onclickEnabled = true; 
					}
				}
				toggleHitBox(){
					if(this.wireFrameEnabled){
						this.wireFrameEnabled = false;
						document.getElementById(this.name).style.border = "none";
					}else {
						this.wireFrameEnabled = true;
						document.getElementById(this.name).style.border = "1px solid black";
					}
				
					
				}
				
				checkCollision(otherEntity) {
					const hitboxReductionPercentage = 0.5; // Adjust this value to reduce the hitbox by a certain percentage
					const hitboxWidthReduction = this.size * (1 - hitboxReductionPercentage);
					const hitboxHeightReduction = this.size * (1 - hitboxReductionPercentage);
								
				
					const rect1 = {
						x: this.x + hitboxWidthReduction / 2,
						y: this.y + hitboxHeightReduction / 2,
						width: this.size - hitboxWidthReduction,
						height: this.size - hitboxHeightReduction
					};
					
					const rect2 = {
						x: otherEntity.x,
						y: otherEntity.y,
						width: otherEntity.size,
						height: otherEntity.size
					};

					if (
						rect1.x < rect2.x + rect2.width &&
						rect1.x + rect1.width > rect2.x &&
						rect1.y < rect2.y + rect2.height &&
						rect1.y + rect1.height > rect2.y
					) {
						// Collision detected
						return true;
						
					}else {
						return false;
					}
				}
				
				
			}
			
			//This function will clear ALL entities in the program, INCLUDING EntityList[0] WHICH IS USUALLY THE PLAYER
				function clearEntities(){
					if (EntityList.length > 0) {
						while (EntityList.length > 0) {
							EntityList[0].remove();
						}
							// Add a confirmation or feedback for the user
							console.log("Room cleared.");
					} else {
							// Add a message if there are no entities to remove
							console.log("No entities to clear.");
					}
				}
			
			//ConversationMenu 
			
			
			
					  // Create the conversationDisplay div
				var conversationDisplay = document.createElement('div');
				conversationDisplay.id = 'conversationDisplay';
				conversationDisplay.className = "contextMenu";
				
				var moveButton = document.createElement("button");
				moveButton.id = "conversationMoveButton";
				moveButton.textContent = "[^]";
				
				moveButton.style.position = "absolute";
				moveButton.style.top = 0 + "px";
				moveButton.style.left = 0 + "px";

				// Create the first span element
				var prompt = document.createElement('span');
				prompt.textContent = 'Prompt';

				// Create the second span element
				var optionsDisplay = document.createElement('span');
				optionsDisplay.textContent = 'Options';

				// Append the span elements to the conversationDisplay div
				conversationDisplay.appendChild(moveButton);
				conversationDisplay.appendChild(prompt);
				conversationDisplay.appendChild(optionsDisplay);

				// Append the conversationDisplay div to the body
				document.body.appendChild(conversationDisplay);
				
				conversationDisplay.OnclickEnabled = false;
				
				
				//Move Conversation Display by pressing the button
				moveButton.onmousedown = function(){
					console.log("Moving Conversation Display");
						if(conversationDisplay.OnclickEnabled){
						conversationDisplay.OnclickEnabled = false;
						}else {
						conversationDisplay.OnclickEnabled = true;
						}
						document.addEventListener('mousemove', (event) => {
									const mouseX = event.clientX;
									const mouseY = event.clientY;
									
									
									
									// You can use mouseX and mouseY wherever needed in your code
										if(conversationDisplay.OnclickEnabled){
											conversationDisplay.style.top = (mouseY-25) + "px";
											conversationDisplay.style.left = (mouseX-25) + "px";
										}
													
						});
					
				}
				
				
				
				
				//Update the Conversation Display (PREVIOUSLY UpdateUI() )
				function UpdateConversationDisplay(){
					prompt.innerHTML = conversationTree.name + " <br> " + conversationTree[conversationNode].text + "<br>";
					
					//Remove all current nodes of options display
					while(optionsDisplay.hasChildNodes()){
							optionsDisplay.removeChild(optionsDisplay.firstChild);
						};

					//Create the new ones
					for(let i = 0; i < conversationTree[conversationNode].options.length; i++){
						const button = document.createElement("button");
						button.innerHTML = conversationTree[conversationNode].options[i].text;
						button.setAttribute('id', "option"+i);
						button.setAttribute('class', 'optionclass')
						
						optionsDisplay.appendChild(button);
						
						button.addEventListener("click",function(){
							conversationNode = conversationTree[conversationNode].options[i].next;
							UpdateConversationDisplay();
						});
					
					};
				};
				
				conversationTree = PreLoad;
				UpdateConversationDisplay();
				
			//Inventory display	
				const InventoryDisplay = document.createElement("div");
				InventoryDisplay.id = "inventoryDisplay";
				InventoryDisplay.className = "InvDisplay";
				
				
				
				document.body.appendChild(InventoryDisplay);
				
				function spawnPlayer(){
					if (EntityList[0]) {
								console.log("Player already spawned.");
							} else {
								// Spawn player sprite as EntityList[0]
								EntityList[0] = new Entity("Eugene", 771, 319, 400, "Player", "Eugene");
								EntityList[0].targetedPos = { x: EntityList[0].x, y: EntityList[0].y };
								
								//Init Inventory
								for(let j = 0; j < EntityList[0].inventory.length; j++){
								InventoryDisplay.innerHTML += " " + EntityList[0].inventory[j].name + " ( " + EntityList[0].inventory[j].quantity + " ) <br>";
								};
								
								EntityList[0].deathInterval = setInterval(() => {
									if(EntityList[0].healthPoints < 0){
										//Show death zone
											
											DeathRoom.generate();
											
											conversationTree = deathConversation;
											conversationNode = "start";
											UpdateConversationDisplay();
											clearInterval(deathInterval);
									}
								}, FRAMERATE);
								
								EntityList[0].keyBoardInterval = setInterval( () => {
									if(pressedKeys[activeControls.moveUp]){
										EntityList[0].targetedPos.y = EntityList[0].y - 20;
									}
									if(pressedKeys[activeControls.moveDown]){
										EntityList[0].targetedPos.y = EntityList[0].y + 20;
									}
									if(pressedKeys[activeControls.moveLeft]){
										EntityList[0].targetedPos.x = EntityList[0].x - 20;
									}
									if(pressedKeys[activeControls.moveRight]){
										EntityList[0].targetedPos.x = EntityList[0].x + 20;
									}
									
									if(pressedKeys["SHIFT"]){
										EntityList[0].moveSpeed = 3;
									}else {
										EntityList[0].moveSpeed = 1;
									}
										for(let i = 0; i < pressedKeys.length; i++){
											pressedKeys[i] = false;
										}
									
								}, FRAMERATE);
					
							};
				};
				
				
				
				
				//The room class is a subclass of Entity class.  This is kind of important, because this class is dependant on the entity class to spawn .
				
				class room {
					constructor(imgUrl, outerLimits, EntitiesToSpawn, SpawnPoint, staticCollisions){
						this.imgUrl = imgUrl;
						this.outerLimits = outerLimits;
						this.EntitiesToSpawn = EntitiesToSpawn;
						this.SpawnPoint = SpawnPoint;
						if(staticCollisions){
							this.staticCollisions = staticCollisions;
						};
						
					}
					generate(){
						
						//So I WAS using ClearEntities() and then spawnPlayer(), but that would init inventory twice and thats not right
						
						for(let i = 1; i < EntityList.length; i++){
							EntityList[i].remove();
						}
						<!-- clearEntities(); -->
						<!-- spawnPlayer(); -->
						
						EntityList[0].x = this.SpawnPoint.x;
						EntityList[0].y = this.SpawnPoint.y;
						
						EntityList[0].targetedPos = { x: this.SpawnPoint.x, y: this.SpawnPoint.y };
						
						mapLimits = this.outerLimits;
						
							for(let i = 0; i < this.EntitiesToSpawn.length; i++){
								EntityList[i+1] = new Entity(	this.EntitiesToSpawn[i].urlFolder, 
																this.EntitiesToSpawn[i].x, 
																this.EntitiesToSpawn[i].y,
																this.EntitiesToSpawn[i].size,
																this.EntitiesToSpawn[i].type,
																this.EntitiesToSpawn[i].name);
								EntityList[i+1].targetedPos = {x: this.EntitiesToSpawn[i].x, y: this.EntitiesToSpawn[i].y};
								
								EntityList[i+1].facedDirection = this.EntitiesToSpawn[i].facedDirection;
								
								EntityList[i+1].conversationTree = this.EntitiesToSpawn[i].linkToConversationTree;
							}
						
						
							this.staticCollisionsInterval = setInterval(() => {
								for(let i = 0; i < this.staticCollisions.length; i++){
									if(EntityList[0].x > this.staticCollisions[i].xMin && EntityList[0].x < this.staticCollisions[i].xMax){
										if(EntityList[0].y > this.staticCollisions[i].yMin && EntityList[0].y < this.staticCollisions[i].yMax){
											EntityList[0].x = EntityList[0].lastPos.x;
											EntityList[0].y = EntityList[0].lastPos.y;
										}
									}
								}
							}, FRAMERATE);
						
						
						
						
						document.body.style.backgroundImage = "url(" + this.imgUrl + ")";
						
					}
				}
				
				
			let EmptyCollisions = [
				//None
				{xMin: 0, xMax: 1, yMin: 0, yMax: 1}, //No dude I promise there is a super rare treasure in this 1x1 pixel bro, go check it out bro i promise bro
			];
				let testStaticCollisions2 = [
					{xMin: 650, xMax: 1260, yMin: 0, yMax: 440}, //HOUSE
					{xMin: 490, xMax: 650, yMin: 50, yMax: 160} //TREE
				];
	
				let EmptyEntitySet = [
					//No enemies in first level
				];
				
				
				let testEntities2 = [
					{urlFolder: "Wendigoo",
					x:1300, y:400,
					size: 400,
					type:"Monster",
					name:"Brother in Christ",
					
					facedDirection: "front",
					linkToConversationTree: TribalLeader
					},
					
					
				];
			
			let generatedRoom1 = new room(	'OutsideHouse.png', 							//BACKGROUND IMAGE
											{xMax: 1980, xMin: 0, yMax: 1280, yMin: 0 }, //MAP LIMITS
											EmptyEntitySet, 									//ENEMY SET
											{x: 550, y:375},								//SPAWN POINT
											testStaticCollisions2);							//STATIC COLLISIONS				
			let ritualRoom = new room(
										"ROOM.png", 							//BACKGROUND IMAGE
										{xMax: 920, xMin: 645, yMax: 475, yMin: 175 }, //MAP LIMITS
										EmptyEntitySet,								//ENEMY SET
										{x: 775, y:375},							//SPAWN POINT
										EmptyCollisions)							//STATIC COLLISIONS
										
			let hallRoom = new room(
										"SecondROOM.png", 							//BACKGROUND IMAGE
										{xMax: 1376, xMin: 220, yMax: 475, yMin: 175 }, //MAP LIMITS
										testEntities2,								//ENEMY SET
										{x: 775, y:375},							//SPAWN POINT
										EmptyCollisions)							//STATIC COLLISIONS
											
			let DeathRoom = new room('DeathZone.png',  {xMax: 890, xMin: 666, yMax: 478, yMin: 228 }, EmptyEntitySet, {x: 750, y:320}, EmptyCollisions);	//PLACE FOR DEATH							
			
			//DEV TOOLKIT
			
			class DevToolkit {
				
				constructor(){
					this.element = document.createElement("div");
					
					this.element.className = "overlayDisplay";
					
				//SPAWN PLAYER BUTTON
					this.spawnButton = document.createElement("button");
					
					
					this.spawnButton.innerHTML = "Spawn Player";
						this.spawnButton.addEventListener("click", spawnPlayer);
					this.element.appendChild(this.spawnButton);
						
				//ROOM ONE 
					this.roomOneButton = document.createElement("button");
					this.roomOneButton.innerHTML = "Room ONE";
					
					this.roomOneButton.onclick = function() {
						generatedRoom1.generate();
						conversationTree = HouseExterior;
						UpdateConversationDisplay();
						
							let doorInterval = setInterval( () => {
								
								if(EntityList[0].x > 960 && EntityList[0].x < 1060 && EntityList[0].y < 450 && EntityList[0].y > 400){
									
									conversationTree = InnerSanctum;
									UpdateConversationDisplay();
									
									ritualRoom.generate();
									clearInterval(generatedRoom1.staticCollisionsInterval)
									clearInterval(doorInterval);
								};
								
							}, FRAMERATE);
							
					}
					
					this.element.appendChild(this.roomOneButton);
					
					
				//ROOM TWO
					this.roomTwoButton = document.createElement("button");
					this.roomTwoButton.innerHTML = "Room TWO";
					
					this.roomTwoButton.onclick = function() {
						hallRoom.generate();
						EntityList[1].healthPoints = 50;
						EntityList[1].attackPower = 2;
						
						EntityList[0].healthPoints = 999;
						EntityList[0].attackPower = 10;
							
					}
					
					this.element.appendChild(this.roomTwoButton);
				
				//CLEAR ROOM
					
					this.clearButton = document.createElement("button");
					
					this.clearButton.innerHTML = "Clear All Entities";
					
					this.clearButton.onclick = () => {
						clearEntities();
					};
					
						this.element.appendChild(this.clearButton);
						
						
				//MOVEMENT button
					this.controlsButton = document.createElement("button");
					this.controlsButton.innerHTML = "CHANGE CONTROLS (WASD)";
					
					this.controlsButton.onclick = () => {
						
						if(activeControls === WASDcontrols){
							activeControls = ArrowControls;
							this.controlsButton.innerHTML = "CHANGE CONTROLS (ARROW)";
							console.log("Switched to Arrow Controls");
						}else {
							activeControls = WASDcontrols;
							this.controlsButton.innerHTML = "CHANGE CONTROLS (WASD)";
							console.log("Switched to WASD Controls");
						}
						
					};
					
					this.element.appendChild(this.controlsButton);
						
				//Turn on all wireframes
					this.wireFrameButton = document.createElement("button");
					
					this.wireFrameButton.innerHTML = "Show All Hitboxes";
					
					this.wireFrameButton.onclick = () => {
						for(let i = 0; i < EntityList.length; i++){
						//okay...so i am making it FALSE first because I am going to toggle it. That WILL be confusing and we WILL end up messing something up. Sucks to suck.
							EntityList[i].wireFrameEnabled = false;
							EntityList[i].toggleHitBox();
						}
					}
					
						this.element.appendChild(this.wireFrameButton);
					
					document.body.appendChild(this.element)
					
					
					
					this.isVisible = true;
					this.toggleVisibility();
				
				
				}
				
				toggleVisibility(){						//Visibility of the Dev Toolkit
					if (this.isVisible) {
						this.element.style.display = "none"; // hide the element
						this.isVisible = false; // update the visibility state
					} else {
						this.element.style.display = "block"; // show the element
						this.isVisible = true; // update the visibility state
					}
				}
				
				
					
					
				
			}
			let DevKit = new DevToolkit();
			
			
			//Add a keylog listener
			
			document.body.addEventListener("keydown", (event) => {
				console.log(event.key);
				
					if(event.key === "Escape"){
						DevKit.toggleVisibility();
					}
			});
			
			
			
			let pressedKeys = [];
			
			document.body.addEventListener("keydown", (event) => {
				
				pressedKeys[event.key.toUpperCase()] = true;
				pressedKeys[event.key.toLowerCase()] = true;
			});
			
			document.body.addEventListener("keyup", (event) => {
			
				pressedKeys[event.key.toUpperCase()] = false;
				pressedKeys[event.key.toLowerCase()] = false;
				
			})
	
	
			window.alert("Press Escape, press 'Spawn Player', press 'SPAWN ROOM FIVE', Try walking through the door!");
			
		</script>
	</body>

</html>

